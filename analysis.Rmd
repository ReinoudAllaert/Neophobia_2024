---
title: "Neophobia analysis"
output:
  html_document:
    df_print: paged
---

## Setup

Load and install R packages:

```{r Dependencies, echo=TRUE}
packages <- c('lmerTest', 'lme4', 'ggplot2', 'tidyverse', 'readxl', 'purrr', 'performance', 'emmeans', 'MASS', 'dplyr', 'tidyr', 'nlme')

# Check if each package is installed; if not, install it
for (pkg in packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
  library(pkg, character.only = TRUE)
}

```

## Data Loading

Grab `neophobia_data.csv` from `processed_data` directory:

```{r Load data}
script_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
# Set the working directory to the script's directory
setwd(script_dir)
data <- read.csv("processed_data/neophobia_data.csv", row.names = 1)

```

## Quick Data Inspection

### Filter out LBBG

Summary statistics of the data:

```{r data summary, fig.width=10, fig.height=10, dpi=300}
# Quick look at structure
str(data)
summary(data)

# 13 birds were ID'd to be LBBG instead of HG, in the RR we stated  we would remove those from the analysis:

LBBG <- c("GY_RY", "BG_RR", "GR_GR", "GG_BR",
          "BG_BY", "GY_PP", "PR_BP", "PY_BY",
          "BP_BY", "BB_RR", "GG_BG", "BB_GY",
          "PR_RY")

data <- data %>% filter(!Bird_ID %in% LBBG)

# There are quite a bit of birds that never ate, let's explore those:
data_not_eat <- data %>% filter(Latency_to_Eat == 600)

# 13/29 not eating trials are from birds that did not eat twice or more 
sort(table(data_not_eat$Bird_ID), decreasing = TRUE)

data_not_eat <- data_not_eat %>%
  group_by(Object, Context) %>%
  summarise(Count = n())
data_not_eat$obj_cont <- paste0(data_not_eat$Object, "_", data_not_eat$Context)

# Almost all of those ocurrences are individual x novel
data_not_eat

# Given that these are actually the most interesting birds, we should keep them in the analysis. There are only 106 individual x novel trials in total. Excluding 29 of them  would mean losing 1/3 of the data.

```

## Data Preprocessing

### Missing Group ID Values

The `GroupID` values are currently coded as `NA` during individual trials. Assign the most frequent group for each bird:

```{r Add grp values}
most_frequent_group <- function(group_ids) {
  group_ids <- group_ids[!is.na(group_ids)]
  if (length(group_ids) == 0) return(NA)
  names(sort(table(group_ids), decreasing = TRUE))[1]
}

most_frequent_group_per_bird <- data %>%
  group_by(Bird_ID) %>%
  summarize(most_frequent_group = most_frequent_group(GroupID)) %>%
  ungroup()

data <- data %>%
  left_join(most_frequent_group_per_bird, by = "Bird_ID") %>%
  mutate(GroupID = ifelse(is.na(GroupID), most_frequent_group, GroupID)) %>%
  dplyr::select(-most_frequent_group)
```

### Adjusting Trial Numbers, so the baseline is the first trial rather than 0.

Adjust the `Trial` variable by subtracting 1:

```{r Set trial nbr}
data$Trial <- data$Trial - 1

```

## Statistical Modeling

### 1) Latency to Enter

The full model as described in the RR, includes `Object_contrast`, `Context_contrast`, and `Trial`, and a complex random effect structure:

```{r Enter model 1, fig.width=10, fig.height=10, dpi=300}
enter_model <- lmer(Latency_to_enter ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(enter_model)
check_model(enter_model)

```

The random effect structure seems to be too complex for the amount of data. However, the variance for the `(Intercept)` under `NestID` is `0` and the variance for `group_dummy` under `GroupID` is `0`. This suggests that both nest as differences between groups contribute minimally to the variance in the outcome model. Let's drop both effects.

```{r Enter model 2, fig.width=10, fig.height=10, dpi=300}
enter_model2 <- lmer(Latency_to_enter ~ Object_contrast * Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(enter_model2)
check_model(enter_model2)
```

Seems like the interaction between object and context is non-significant, let's drop it. Given the non-normal distribution, let's logtransform the data as well:

```{r Enter model 3, fig.width=10, fig.height=10, dpi=300}
enter_model3 <- lmer(log(Latency_to_enter) ~ Object_contrast + Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(enter_model3)
check_model(enter_model3)

```

There are still issues with the data distribution, let's boxcox_transform:

```{r Enter model 4, fig.width=10, fig.height=10, dpi=300}

boxcox_transform <- boxcox(lm(Latency_to_enter ~ Object_contrast + Context_contrast + Trial, data = data))
best_lambda <- boxcox_transform$x[which.max(boxcox_transform$y)]

data$Latency_to_enter_trans <- (data$Latency_to_enter^best_lambda - 1) / best_lambda

enter_model4_boxcox <- lmer(Latency_to_enter_trans ~ Object_contrast + 
                              Context_contrast + Trial + 
                            (-1 + ind_dummy + group_dummy | Bird_ID), 
                            data = data)
summary(enter_model4_boxcox)
check_model(enter_model4_boxcox)
```

Comparing the different models, the boxcox transfromed comes out as best:

```{r Compare entering models}
anova(enter_model, enter_model2, enter_model3, enter_model4_boxcox)
```

### 2) Latency to Eat Model

A similar model is built for `Latency_to_Eat`, again incorporating interaction terms and random effects:

```{r Eat model 1, fig.width=10, fig.height=10, dpi=300}
# Given that the distribution of DV is similar to that of the enter model, we log transformed .
eat_model <- lmer(log(Latency_to_Eat) ~ Object_contrast * Context_contrast + Trial + 
                    (1 | NestID) + 
                   (- 1 + group_dummy | GroupID) + 
                   (- 1 + ind_dummy + group_dummy | Bird_ID),  
                 data = data)
summary(eat_model)
check_model(eat_model)
```

Similarly, the variance for the `(Intercept)` under `NestID` is `0` and the variance for `group_dummy` under `GroupID` is `0`. Let's drop those:

```{r Eat model 2, fig.width=10, fig.height=10, dpi=300}

eat_model2 <- lmer(log(Latency_to_Eat) ~ Object_contrast * Context_contrast + Trial + 
                   (- 1 + ind_dummy + group_dummy | Bird_ID),  
                 data = data)
summary(eat_model2)
check_model(eat_model2)

```

There are still some issues with the normality. Let's try the same boxcox tranformation:

```{r Eat model 3, fig.width=10, fig.height=10, dpi=300}

boxcox_transform <- boxcox(lm(Latency_to_Eat ~ Object_contrast * Context_contrast + Trial, data = data))
best_lambda <- boxcox_transform$x[which.max(boxcox_transform$y)]

data$Latency_to_eat_trans <- (data$Latency_to_Eat^best_lambda - 1) / best_lambda

eat_model4_boxcox <- lmer(Latency_to_eat_trans ~ Object_contrast * 
                              Context_contrast + Trial + 
                            (-1 + ind_dummy + group_dummy | Bird_ID), 
                            data = data)

summary(eat_model4_boxcox)
check_model(eat_model4_boxcox)
```

boxcox model seems to fit data best, but still a correlation of 1, which is problematic... Potentially use nlme?

```{r}
eat_model_nlme <- lme(Latency_to_eat_trans ~ Object_contrast * Context_contrast + Trial, 
                      random = ~ 1 | Bird_ID,
                      weights = varIdent(form = ~ 1 | Context),  
                      data = data)

summary(eat_model_nlme)
check_model(eat_model_nlme)
```

Or model contexts separately?

```{r}
# model for group context
eat_model_group <- lmer(Latency_to_eat_trans ~ Object_contrast + Trial + 
                        (1 | Bird_ID), 
                        data = subset(data, Context == "group"))

# model for individual context
eat_model_alone <- lmer(Latency_to_eat_trans ~ Object_contrast  + Trial + 
                        (1 | Bird_ID), 
                        data = subset(data, Context == "individual"))

# Compare variances
summary(eat_model_group)
summary(eat_model_alone)
```

```{r Compare eat models}

anova(eat_model, eat_model2, eat_model4_boxcox)

```

### 3) Time spent in the ZOI

The full model as described in the RR, includes `Object_contrast`, `Context_contrast`, and `Trial`, and a complex random effect structure:

```{r ZOI model 1, fig.width=10, fig.height=10, dpi=300}
zoi_model <- lmer(Zoi_duration ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(zoi_model)
check_model(zoi_model)

```

Here the full model seems to fit, lets try with a simpeler ranef structure though:

```{r ZOI model 2, fig.width=10, fig.height=10, dpi=300}
zoi_model2 <- lmer(Zoi_duration ~ Object_contrast * Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(zoi_model2)
check_model(zoi_model2)
```

There are still issues with the data distribution, let's boxcox_transform:

```{r ZOI model 3, fig.width=10, fig.height=10, dpi=300}

boxcox_transform <- boxcox(lm(Zoi_duration+ 0.01 ~ Object_contrast * Context_contrast + Trial, data = data))
best_lambda <- boxcox_transform$x[which.max(boxcox_transform$y)]

data$Latency_to_zoi_trans <- (data$Zoi_duration^best_lambda - 1) / best_lambda

zoi_model4_boxcox <- lmer(Latency_to_zoi_trans ~ Object_contrast * 
                              Context_contrast + Trial + 
                            (-1 + ind_dummy + group_dummy | Bird_ID), 
                            data = data)
summary(zoi_model4_boxcox)
check_model(zoi_model4_boxcox)
```

Comparing the different models, the boxcox comes out as best:

```{r Compare ZOI models}

anova(zoi_model, zoi_model2, zoi_model4_boxcox)

```

So we end up with these models:

```{r Summarise models}
# To enter
summary(enter_model4_boxcox)

# To eat
summary(eat_model4_boxcox)

# Time near object
summary(zoi_model4_boxcox)
```

#### So for entering:

##### Fixed Effects:

Context is significant, with birds being faster in groups compared to being alone. In addition trial is significant, with birds becoming faster over time.

##### Random Effects:

Variance: The variance is higher for individual trials, suggesting that there is more variability in how long birds take to enter when they are alone.

#### So for eating:

##### Fixed Effects:

Object_contrast: Birds take longer to start eating when the object is novel. Context_contrast: Birds are quicker to eat when they are in a group compared to when they are alone.

##### Random Effects:

Variance: There is slightly more variability in the latency to eat during individual trials, indicating that birds' responses to novelty are more variable when they are alone. However the values are in the same ballpark.

#### So for ZOI:

##### Fixed Effects:

Context_contrast: Birds spend more time near objects when they are in a group compared to when they are alone. Trial: Time near objects increases over time. Interaction between Object_contrast and Context_contrast: Suggests that the effect of object novelty on the time spent near the object depends on whether the birds are alone or in a group. In a group, birds may be more willing to spend time near a novel object, while alone, they might avoid it more quickly.

##### Random Effects:

Variance: The variance is higher for individual trials, indicating variability in how long individual birds spend near novel objects when they are alone. Potentially reflects differences in individual boldness or fearfulness in the absence of a group.

## Multivariate analysis

Now fit a multivariate model:

```{r multivariate model 1}
# make data long:
data_long <- data %>%
  pivot_longer(
    cols = c(Latency_to_enter, Latency_to_Eat),
    names_to = "Behaviour_Type",
    values_to = "Latency"
  )
data_long <- data_long %>%
  mutate(
    eat_vs_leave_contrast = case_when(
      Behaviour_Type == "Latency_to_enter" ~ -0.5,
      Behaviour_Type == "Latency_to_Eat" ~ 0.5
    )
  )

# fir full model
latency_model <- lmer(Latency ~ eat_vs_leave_contrast * Object_contrast * Context_contrast + Trial + 
                    (1 | NestID) +
                    (- 1 + group_dummy | GroupID) + 
                    (- 1 + ind_dummy + group_dummy + eat_vs_leave_contrast | Bird_ID), 
                  data = data_long)

summary(latency_model)

```

Same as before, reduce the model:

```{r multivariate model 2, fig.width=10, fig.height=10, dpi=300}

latency_model2 <- lmer(Latency ~ eat_vs_leave_contrast * Object_contrast * Context_contrast + Trial + 
                    (- 1 + ind_dummy + group_dummy + eat_vs_leave_contrast | Bird_ID), 
                  data = data_long)

summary(latency_model2)
check_model(latency_model2)

```

Same as before, boxcox transfrom the data:

```{r multivariate model 3, fig.width=10, fig.height=10, dpi=300}


boxcox_transform <- boxcox(lm(Latency ~ eat_vs_leave_contrast * Object_contrast * Context_contrast + Trial, data = data_long))
best_lambda <- boxcox_transform$x[which.max(boxcox_transform$y)]

data_long$Latency_trans <- (data_long$Latency^best_lambda - 1) / best_lambda



latency_model3_boxcox <- lmer(Latency_trans ~ eat_vs_leave_contrast * Object_contrast * Context_contrast + Trial + 
                    (- 1 + ind_dummy + group_dummy + eat_vs_leave_contrast | Bird_ID), 
                  data = data_long)

summary(latency_model3_boxcox)
check_model(latency_model3_boxcox)


```

There are still issues with the ranef structure, simpligy the model:

```{r multivariate model 4, fig.width=10, fig.height=10, dpi=300}
latency_model3_boxcox_reduced <- lmer(Latency_trans ~ eat_vs_leave_contrast * Object_contrast * Context_contrast +
                                       Trial + 
                                       (-1 + ind_dummy + group_dummy  | Bird_ID), 
                                     data = data_long)

# Summary of the updated model
summary(latency_model3_boxcox_reduced)

# Check the model diagnostics
check_model(latency_model3_boxcox_reduced)
```

I would say the multivariate model supports what the we found earlier. 3-way interaction is nonsign, so lets remove it:

```{r multivariate model 5, fig.width=10, fig.height=10, dpi=300}
latency_model3_boxcox_reduced_2 <- lmer(Latency_trans ~ eat_vs_leave_contrast * Object_contrast +
                                       eat_vs_leave_contrast * Context_contrast +
                                       Object_contrast * Context_contrast +
                                       Trial + 
                                       (-1 + ind_dummy + group_dummy  | Bird_ID), 
                                     data = data_long)

# Summary of the updated model
summary(latency_model3_boxcox_reduced_2)

# Check the model diagnostics
check_model(latency_model3_boxcox_reduced_2)
```

```{r Compare multivariate models }
anova(latency_model3_boxcox_reduced_2, latency_model3_boxcox_reduced, latency_model3_boxcox, latency_model2, latency_model)
```

latency_model3_boxcox seems to be the best fit, but gives warnings.









##############################################################################
##############################################################################
##############################################################################

## Some descriptives


```{r Descriptives}

# Load package
library(dplyr)

# Descriptive stats function latencies
calculate_stats <- function(data, var) {
  summarise(data,
            mean_value = mean({{var}}, na.rm = TRUE),  # Include 600s in the mean calculation
            min_value = min({{var}}, na.rm = TRUE),    # Include 600s in the min calculation
            max_value = max({{var}}[{{var}} != 600], na.rm = TRUE),  # Exclude 600s from max calculation
            count_600 = sum({{var}} == 600, na.rm = TRUE))  # Count how many 600s
}

# Descriptive stats function for ZOI (considering 0 values)
calculate_stats_zoi <- function(data, var) {
  summarise(data,
            mean_value = mean({{var}}, na.rm = TRUE),  # Include 0s in the mean calculation
            min_value = min({{var}}[{{var}} != 0], na.rm = TRUE),  # Exclude 0s from min calculation
            max_value = max({{var}}, na.rm = TRUE),  # Include 0s in max calculation
            count_0 = sum({{var}} == 0, na.rm = TRUE))  # Count how many 0s
}

# Calculate stats for latency to enter, latency to eat, and time spent in ZOI
# Group by Context and Object, then calculate for each combination
stats_latency_enter <- data %>%
  group_by(Context, Object) %>%
  calculate_stats(Latency_to_enter)

stats_latency_eat <- data %>%
  group_by(Context, Object) %>%
  calculate_stats(Latency_to_Eat)

stats_time_ZOI <- data %>%
  group_by(Context, Object) %>%
  calculate_stats_zoi(Zoi_duration)

# Print results
print("Latency to Enter - Stats:")
print(stats_latency_enter)

print("Latency to Eat - Stats:")
print(stats_latency_eat)

print("Time Spent in ZOI - Stats:")
print(stats_time_ZOI)



### Descriptives for Object and Context separately 

# Calculate stats for Object alone
stats_object_latency_enter <- data %>%
  group_by(Object) %>%
  calculate_stats(Latency_to_enter)

stats_object_latency_eat <- data %>%
  group_by(Object) %>%
  calculate_stats(Latency_to_Eat)

stats_object_time_ZOI <- data %>%
  group_by(Object) %>%
  calculate_stats_zoi(Zoi_duration)

print("Latency to Enter - Stats (Object):")
print(stats_object_latency_enter)

print("Latency to Eat - Stats (Object):")
print(stats_object_latency_eat)

print("Time Spent in ZOI - Stats (Object):")
print(stats_object_time_ZOI)


# Calculate stats for Context alone
stats_context_latency_enter <- data %>%
  group_by(Context) %>%
  calculate_stats(Latency_to_enter)

stats_context_latency_eat <- data %>%
  group_by(Context) %>%
  calculate_stats(Latency_to_Eat)

stats_context_time_ZOI <- data %>%
  group_by(Context) %>%
  calculate_stats_zoi(Zoi_duration)

print("Latency to Enter - Stats (Context):")
print(stats_context_latency_enter)

print("Latency to Eat - Stats (Context):")
print(stats_context_latency_eat)

print("Time Spent in ZOI - Stats (Context):")
print(stats_context_time_ZOI)


```



# Plot the Object x Context interaction

```{r Plot of descriptives}

# Load packages
library(ggplot2)
library(dplyr)

# Calculate summary stats for plotting (mean and standard error)
calculate_summary <- function(data, var) {
  data %>%
    group_by(Context, Object) %>%
    summarise(mean_value = mean({{var}}, na.rm = TRUE),
              se_value = sd({{var}}, na.rm = TRUE) / sqrt(n()),
              .groups = "drop")
}

# Summarise data for each variable
summary_latency_enter <- calculate_summary(data, Latency_to_enter)
summary_latency_eat <- calculate_summary(data, Latency_to_Eat)
summary_time_ZOI <- calculate_summary(data, Zoi_duration)

# Function to plot
plot_variable <- function(data, var_name, y_label) {
  ggplot(data, aes(x = interaction(Context, Object), y = mean_value, fill = Object)) +
    geom_bar(stat = "identity", position = position_dodge(), width = 0.4) +
    geom_errorbar(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                  width = 0.2, position = position_dodge(0.7)) +
    labs(x = "Context and Object", y = y_label, title = paste(var_name, "by Context and Object")) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("novel" = "goldenrod", "control" = "lightblue")) 
}

# Plot latency to enter
plot_latency_enter <- plot_variable(summary_latency_enter, "Latency to Enter", "Mean Latency (s)")
print(plot_latency_enter)

# Plot latency to eat
plot_latency_eat <- plot_variable(summary_latency_eat, "Latency to Eat", "Mean Latency (s)")
print(plot_latency_eat)

# Plot time spent in ZOI
plot_time_ZOI <- plot_variable(summary_time_ZOI, "Time Spent in ZOI", "Mean Time (s)")
print(plot_time_ZOI)


```



##########################################################################################################
##########################################################################################################


# Statistical analysis

### NOT transformed

### Latency to enter 

```{r Enter model 1, fig.width=10, fig.height=10, dpi=300}
enter_model <- lmer(Latency_to_enter ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(enter_model)
check_model(enter_model)

```


Remove complex random effect structure

```{r Enter model 2, fig.width=10, fig.height=10, dpi=300}
enter_model2 <- lmer(Latency_to_enter ~ Object_contrast * Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(enter_model2)
check_model(enter_model2)
```


Drop interaction

```{r Enter model 3, fig.width=10, fig.height=10, dpi=300}
enter_model3 <- lmer(Latency_to_enter ~ Object_contrast + Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(enter_model3)
check_model(enter_model3)

```


Now we can compare the models

```{r Compare models}

anova(enter_model, enter_model2, enter_model3)

```




### Latency to Eat

```{r Eat model 1, fig.width=10, fig.height=10, dpi=300}
eat_model <- lmer(Latency_to_Eat ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(eat_model)
check_model(eat_model)

```


Remove complex random effect structure

```{r Eat model 2, fig.width=10, fig.height=10, dpi=300}
eat_model2 <- lmer(Latency_to_Eat ~ Object_contrast * Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(eat_model2)
check_model(eat_model2)
```


Now we can compare the models

```{r Compare models}

anova(eat_model, eat_model2)

```



### ZOI Duration 

```{r Zoi model 1, fig.width=10, fig.height=10, dpi=300}
zoi_model <- lmer(Zoi_duration ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(zoi_model)
check_model(zoi_model)

```


Remove complex random effect structure

```{r Zoi model 2, fig.width=10, fig.height=10, dpi=300}
zoi_model2 <- lmer(Zoi_duration ~ Object_contrast * Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(zoi_model2)
check_model(zoi_model2)
```


Now we can compare the models

```{r Compare models}

anova(zoi_model, zoi_model2)

```




##########################################################################################################
##########################################################################################################

# Try some GLMM to potentially avoid Box-Cox 

### Latency to Enter

The full model as described in the RR:

```{r Enter GLMM, fig.width=10, fig.height=10, dpi=300}
enter_model_gaus <- glmer(Latency_to_enter ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              family=gaussian(link = "log"), data = data)

summary(enter_model_gaus)
check_model(enter_model_gaus)

```


```{r Enter GLMM, fig.width=10, fig.height=10, dpi=300}
enter_model_gamma <- glmer(Latency_to_enter ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              family=Gamma(link = "log"), data = data)

summary(enter_model_gamma)
check_model(enter_model_gamma)

```


### Latency to Eat

The full model as described in the RR:

```{r Enter GLMM, fig.width=10, fig.height=10, dpi=300}
eat_model_gaus <- glmer(Latency_to_Eat ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              family=gaussian(link = "log"), data = data)

summary(eat_model_gaus)
check_model(eat_model_gaus)

```


```{r Enter GLMM, fig.width=10, fig.height=10, dpi=300}
eat_model_gamma <- glmer(Latency_to_Eat ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              family=Gamma(link = "log"), data = data)

summary(eat_model_gamma)
check_model(eat_model_gamma)

```



### ZOI Duration

The full model as described in the RR:

```{r Enter GLMM, fig.width=10, fig.height=10, dpi=300}
zoi_model_gaus <- glmer(Zoi_duration ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              family=gaussian(link = "log"), data = data)

summary(zoi_model_gaus)
check_model(zoi_model_gaus)

```


```{r Enter GLMM, fig.width=10, fig.height=10, dpi=300}
enter_model_gamma <- glmer(Zoi_duration ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              family=Gamma(link = "log"), data = data)

summary(zoi_model_gamma)
check_model(zoi_model_gamma)

```


Doesn't really improve the data. 



##########################################################################################################
##########################################################################################################


## All models Box-Cox transformed 

### Latency to Enter

```{r compute lambda}


# Load the required package
library(MASS)

# Perform the Box-Cox transformation and find the best lambda
boxcox_transform_enter <- boxcox(lm(Latency_to_enter ~ Object_contrast + Context_contrast + Trial, data = data))
best_lambda_enter <- boxcox_transform_enter$x[which.max(boxcox_transform_enter$y)]

# Calculate the 95% confidence interval for lambda
max_log_likelihood_enter <- max(boxcox_transform_enter$y)
ci_indices_enter <- which(boxcox_transform_enter$y > (max_log_likelihood_enter - 1.96)) 
lambda_ci_enter <- range(boxcox_transform_enter$x[ci_indices_enter])

# Print the best lambda and the 95% confidence interval
cat("Best lambda:", best_lambda_enter, "\n")
cat("95% Confidence Interval for lambda:", lambda_ci_enter, "\n")
print(best_lambda_enter)

data$Latency_to_enter_trans <- (data$Latency_to_enter^best_lambda_enter - 1) / best_lambda_enter


```


# boxcox full model

```{r Enter model 1, fig.width=10, fig.height=10, dpi=300}

enter_model_bc1 <- lmer(Latency_to_enter_trans ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(enter_model_bc1)
check_model(enter_model_bc1)



```



# boxcox model reduced random effect structure

```{r Enter model 1, fig.width=10, fig.height=10, dpi=300}

enter_model_bc2 <- lmer(Latency_to_enter_trans ~ Object_contrast * Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(enter_model_bc2)
check_model(enter_model_bc2)


```


# drop interaction because it is not significant

```{r Enter model 1, fig.width=10, fig.height=10, dpi=300}

enter_model_bc3 <- lmer(Latency_to_enter_trans ~ Object_contrast * Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(enter_model_bc3)
check_model(enter_model_bc3)


```



# let's compare the boxcox models

```{r Compare models}


anova(enter_model_bc1, enter_model_bc2, enter_model_bc3)



```



# Backtransform via predictions

Not sure yet whether the predictions work like that especially if we can make predictions like this for main effects when our model has an interaction term (R gives a warning, that the results for the main effects may be misleading due to the interaction). 

```{r Backtransform}
library(emmeans)

bctran_enter <- make.tran("boxcox", -0.8686869)

# Use emmeans to compute and back-transform the results
emms_bc <- emmeans(
  enter_model_bc2,
  specs = ~ Context_contrast | Object_contrast,
  type = "response",
  tran = bctran_enter
)

# View the back-transformed results
emms_bc



# Compute marginal means for Context contrast
emms_context <- emmeans(
  enter_model_bc2,
  specs = "Context_contrast",  # Only get predictions for Context_contrast
  type = "response",
  tran = bctran_enter  # Use the Box-Cox transformation for back-transformation
)

# View the predictions
emms_context


# Compute marginal means for Object contrast
emms_object <- emmeans(
  enter_model_bc2,
  specs = "Object_contrast",  # Only get predictions for Object_contrast
  type = "response",
  tran = bctran_enter  # Use the Box-Cox transformation for back-transformation
)

# View the predictions
emms_object



### Trial - compute it as a factor first. 
# Otherwise it is treated as continuous and just predicts it for the average trial (3.5) 

data$Trial <- as.factor(data$Trial)

enter_model_bc2 <- lmer(
  Latency_to_enter_trans ~ Object_contrast * Context_contrast + factor(Trial) + 
  (-1 + ind_dummy + group_dummy | Bird_ID), 
  data = data
)

# Compute marginal means for Trial
emms_trial <- emmeans(
  enter_model_bc2,
  specs = "Trial",  # just averages the trial then
  type = "response",
  tran = bctran_enter  # Use the Box-Cox transformation for back-transformation
)

# View the predictions
emms_trial

```




########################################################################################################




### Latency to Eat

```{r Compute lambda}
# Load the required package
library(MASS)

# Perform the Box-Cox transformation and find the best lambda
boxcox_transform_eat <- boxcox(lm(Latency_to_Eat ~ Object_contrast + Context_contrast + Trial, data = data))
best_lambda_eat <- boxcox_transform_eat$x[which.max(boxcox_transform_eat$y)]

# Calculate the 95% confidence interval for lambda
max_log_likelihood_eat <- max(boxcox_transform_eat$y)
ci_indices_eat <- which(boxcox_transform_eat$y > (max_log_likelihood_eat - 1.96))  
lambda_ci_eat <- range(boxcox_transform_eat$x[ci_indices_eat])

# Print the best lambda and the 95% confidence interval
cat("Best lambda:", best_lambda_eat, "\n")
cat("95% Confidence Interval for lambda:", lambda_ci_eat, "\n")
print(best_lambda_eat)

data$Latency_to_eat_trans <- (data$Latency_to_Eat^best_lambda_eat - 1) / best_lambda_eat

```


```{r Eat BC model 1, fig.width=10, fig.height=10, dpi=300}

# Model

eat_model_bc1 <- lmer(Latency_to_eat_trans ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(eat_model_bc1)
check_model(eat_model_bc1)


```



# boxcox model reduced random effect structure

```{r Eat BC model 2, fig.width=10, fig.height=10, dpi=300}

eat_model_bc2 <- lmer(Latency_to_eat_trans ~ Object_contrast * Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(eat_model_bc2)
check_model(eat_model_bc2)


```



# let's compare the boxcox models

```{r Compare models}

anova(eat_model_bc1, eat_model_bc2)

```



# Backtransform via predictions


```{r Backtransform}
library(emmeans)


bctran_eat <- make.tran("boxcox", -0.8686869) # seems a bit odd latency to enter and eat have the same lambda?

# Use emmeans to compute and back-transform the results
emms_bc_eat <- emmeans(
  eat_model_bc2,
  specs = ~ Context_contrast | Object_contrast,
  type = "response",
  tran = bctran_eat
)

# View the back-transformed results
emms_bc_eat



# Compute marginal means for Context contrast
emms_context_eat <- emmeans(
  eat_model_bc2,
  specs = "Context_contrast",  # Only get predictions for Context_contrast
  type = "response",
  tran = bctran_eat  # Use the Box-Cox transformation for back-transformation
)

# View the predictions
emms_context_eat


# Compute marginal means for Object contrast
emms_object_eat <- emmeans(
  eat_model_bc2,
  specs = "Object_contrast",  # Only get predictions for Object_contrast
  type = "response",
  tran = bctran_eat  # Use the Box-Cox transformation for back-transformation
)

# View the predictions
emms_object_eat



### Trial - compute it as a factor first. 
# Otherwise it is treated as continuous and just predicts it for the average trial (3.5) 

data$Trial <- as.factor(data$Trial)

eat_model_bc2 <- lmer(
  Latency_to_eat_trans ~ Object_contrast * Context_contrast + factor(Trial) + 
  (-1 + ind_dummy + group_dummy | Bird_ID), 
  data = data
)

# Compute marginal means for Trial
emms_trial_eat <- emmeans(
  eat_model_bc2,
  specs = "Trial",  # just averages the trial then
  type = "response",
  tran = bctran_eat  # Use the Box-Cox transformation for back-transformation
)

# View the predictions
emms_trial_eat

```



########################################################################################################




### ZOI Duration 

```{r Zoi model 1, fig.width=10, fig.height=10, dpi=300}

# Load the required package
library(MASS)

data$Zoi_duration_adj <- data$Zoi_duration + 0.1 # add a small constant because Box-Cox cannot be done on 0s

# Perform the Box-Cox transformation and find the best lambda
boxcox_transform_zoi <- boxcox(lm(Zoi_duration_adj ~ Object_contrast + Context_contrast + Trial, data = data))
best_lambda_zoi <- boxcox_transform_zoi$x[which.max(boxcox_transform_zoi$y)]

# Calculate the 95% confidence interval for lambda
max_log_likelihood_zoi <- max(boxcox_transform_zoi$y)
ci_indices_zoi <- which(boxcox_transform_zoi$y > (max_log_likelihood_zoi - 1.96))
lambda_ci_zoi <- range(boxcox_transform_zoi$x[ci_indices_zoi])

# Print the best lambda and the 95% confidence interval
cat("Best lambda:", best_lambda_zoi, "\n")
cat("95% Confidence Interval for lambda:", lambda_ci_zoi, "\n")
print(best_lambda_zoi)

data$zoi_duration_trans <- (data$Zoi_duration_adj^best_lambda_zoi - 1) / best_lambda_zoi

```


# boxcox full model

```{r Model}

zoi_model_bc1 <- lmer(zoi_duration_trans ~ Object_contrast * Context_contrast + Trial + 
                (1 | NestID) + 
                (-1 + group_dummy | GroupID) + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(zoi_model_bc1)
check_model(zoi_model_bc1)


```



# boxcox model reduced random effect structure

```{r Enter model 1, fig.width=10, fig.height=10, dpi=300}

zoi_model_bc2 <- lmer(zoi_duration_trans ~ Object_contrast * Context_contrast + Trial + 
                (-1 +  ind_dummy + group_dummy | Bird_ID), 
              data = data)

summary(zoi_model_bc2)
check_model(zoi_model_bc2)


```


# let's compare the boxcox models

```{r Compare models}

anova(zoi_model_bc1, zoi_model_bc2)

```



# Backtransform via predictions


```{r Backtransform}
library(emmeans)


bctran_zoi <- make.tran("boxcox", 0.3030303) 

# Use emmeans to compute and back-transform the results
emms_bc_zoi <- emmeans(
  zoi_model_bc2,
  specs = ~ Context_contrast | Object_contrast,
  type = "response",
  tran = bctran_zoi
)

# View the back-transformed results
emms_bc_zoi



# Compute marginal means for Context contrast
emms_context_zoi <- emmeans(
  zoi_model_bc2,
  specs = "Context_contrast",  # Only get predictions for Context_contrast
  type = "response",
  tran = bctran_zoi  # Use the Box-Cox transformation for back-transformation
)

# View the predictions
emms_context_zoi


# Compute marginal means for Object contrast
emms_object_zoi <- emmeans(
  zoi_model_bc2,
  specs = "Object_contrast",  # Only get predictions for Object_contrast
  type = "response",
  tran = bctran_zoi  # Use the Box-Cox transformation for back-transformation
)

# View the predictions
emms_object_zoi



### Trial - compute it as a factor first. 
# Otherwise it is treated as continuous and just predicts it for the average trial (3.5) 

data$Trial <- as.factor(data$Trial)

zoi_model_bc2 <- lmer(
  zoi_duration_trans ~ Object_contrast * Context_contrast + factor(Trial) + 
  (-1 + ind_dummy + group_dummy | Bird_ID), 
  data = data
)


# Compute marginal means for Trial
emms_trial_zoi <- emmeans(
  zoi_model_bc2,
  specs = "Trial",  # compute it as a factor before 
  type = "response",
  tran = bctran_zoi  # Use the Box-Cox transformation for back-transformation
)

# View the predictions
emms_trial_zoi

```
















